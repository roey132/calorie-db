#![allow(unused_imports)]
use chrono::NaiveDate;
use diesel::RunQueryDsl;
use rand::{distributions::Alphanumeric, Rng};
use uuid::Uuid;

use crate::{establish_connection, product_measures::*, products::*, user_meals::*, users::*};

use crate::schema::sql_types::MealType;
use crate::schema::users;
#[derive(crate::Insertable)]
#[diesel(table_name = users)]
pub struct AdminUser<'a> {
    pub user_id: Uuid,
    pub username: &'a str,
    pub password: &'a str,
}

#[test]
fn create_sys_user() {
    let system_uuid = Uuid::parse_str("169c6748-72aa-4c08-b6a8-b6c6ed491078").unwrap();
    let system_username = "system";
    let system_password = "calorie_db_system";

    let admin = AdminUser {
        user_id: system_uuid,
        username: system_username,
        password: system_password,
    };
    let conn = &mut establish_connection();

    let _ = diesel::insert_into(users::table)
        .values(admin)
        .execute(conn);
}

#[test]
fn tests() {
    // create connections and rand user name
    let conn = &mut establish_connection();
    let random_string: String = rand::thread_rng()
        .sample_iter(&Alphanumeric)
        .take(5)
        .map(char::from)
        .collect();

    // test user creation
    create_user(conn, random_string.clone(), "password".to_string()).unwrap();

    // get user uuid (generated by db)
    let user_id = get_user_uuid(conn, &random_string).unwrap().user_id;

    // test product creation for user
    create_product_for_user(conn, "potato", 5.0, &user_id).unwrap();
    create_product_for_user(conn, "cucumber", 0.0, &user_id).unwrap();

    // get vector of products for that use (products that just got created)
    let mut user_products = get_products_by_user(conn, Some(user_id)).unwrap();
    let first_product = user_products.remove(0);

    // set product id to check on updates and get functions
    let product_id = first_product.product_id;

    get_product_by_id(conn, product_id).unwrap();
    update_product_by_id(conn, product_id, "egg", 100.0).unwrap();

    // test measurement functions
    create_product_measure(conn, product_id, "test_measure", 300.0, false).unwrap();
    create_product_measure(conn, product_id, "test_measure_2", 200.0, false).unwrap();

    get_product_measure_by_measure_id(conn, 1).unwrap();
    get_product_measures_by_product(conn, product_id).unwrap();

    let date = NaiveDate::from_ymd_opt(2024, 12, 12).unwrap();
    create_user_meal_measure(conn, &user_id, 1, 2.5, date).unwrap();
    create_user_meal_product(conn, &user_id, product_id, 100, date).unwrap();
    create_user_meal_calories(conn, &user_id, Some("Test Calories Meal Name"), 150.0, date)
        .unwrap();
}

#[test]
fn test_products_by_user() {
    let conn = &mut establish_connection();
    let products = get_products_by_user(
        conn,
        Some(
            Uuid::parse_str("26b732bd-fbd0-4f88-ae40-11665a10796b")
                .expect("this parse doesnt work"),
        ),
    )
    .unwrap();
    println!("this test prints");
    println!("{}", products.len().to_string());
}
